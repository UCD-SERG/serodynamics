---
title: "Chapter 2 — Fake Data First, Then Fit"
author: "Kwan Ho Lee"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-fold: true
    code-tools: true
    code-summary: "Show R Code"
    code-fold-default: true
execute:
  echo: true
  warning: false
  message: false
  eval: false
---

# Current Model (what we already fit)

-   Chapter 1 model fits subject-level parameters for each biomarker $(y_0, t_1, y_1, \alpha, \rho)$.
-   Within each biomarker: variation is captured by a covariance $(\Sigma_P)$.
-   Across biomarkers: independence (block-diagonal), i.e. $$
    \mathrm{Cov}\!\big(\mathrm{vec}(\Theta_i)\big) = \Sigma_P \otimes I_B
    $$

# Step A — Set up

```{r}
set.seed(123)
library(tidyverse)
library(mvtnorm)   # rmvnorm
library(Matrix)    # kronecker
library(serodynamics)
```

# Step B — Helper functions (now in package)

All helper functions for this chapter have been moved to the `serodynamics` package:

- `simulate_multi_b_long()`: Simulates correlated multi-biomarker data with Kronecker covariance
- `prep_priors_multi_b()`: Prepares Wishart hyperparameters for the Kronecker model
- `write_model_ch2_kron()`: Writes the JAGS model file with Kronecker precision
- `clean_priors()`: Removes fields like `omega`, `wishdf`, `prec.par` that conflict with Kronecker priors
- `build_kron_priors()`: Internal helper that combines base and Kronecker priors

These functions are documented and tested. See `?simulate_multi_b_long` for examples.


# Step C — Choose a “truth” and simulate fake data

```{r}

# Choose B biomarkers and visit schedule
n_blocks  <- 2
time_grid <- c(0, 7, 14, 30)

# True ΣP (5×5): mild positive correlation among the five latent parameters
sd_p <- c(0.35, 0.45, 0.25, 0.30, 0.25)
R_p  <- matrix(0.25, 5, 5)
diag(R_p) <- 1
sigma_p <- diag(sd_p) %*% R_p %*% diag(sd_p)

# True ΣB (B×B): cross-biomarker correlation
R_b <- matrix(c(1, 0.5,
                0.5, 1), n_blocks, n_blocks, byrow = TRUE)
sd_b <- rep(0.6, n_blocks)
sigma_b <- diag(sd_b) %*% R_b %*% diag(sd_b)


# Run simulator
sim <- simulate_multi_b_long(
  n_id      = 5,
  n_blocks  = n_blocks,
  time_grid = time_grid,
  sigma_p   = sigma_p,
  sigma_b   = sigma_b
)

# This long table already matches prep_data() expectations:

sim$data |> dplyr::slice_head(n = 8)
```

# Step D — Fit the independence model

```{r}
# If our package is loaded, this is all we need:

sim_tbl <- serodynamics::as_case_data(
  sim$data,
  id_var        = "Subject",
  biomarker_var = "antigen_iso",
  value_var     = "value",
  time_in_days  = "time_days"
)

prepped <- prep_data(sim_tbl)
priors  <- prep_priors(max_antigens = prepped$n_antigen_isos)
fit_v0  <- run_mod(
 data     = sim_tbl,
 file_mod = serodynamics_example("model.jags"),  # our current model
 nchain = 4, nadapt = 1000, nburn = 500, nmc = 500, niter = 5000,
 strat = NA, with_post = TRUE
 )

fit_v0
```

# Step E — Prepare for Correlated Model

-   In Step D we fit the “independence” model: each biomarker had its own covariance for the 5 parameters, but biomarkers were assumed independent.
-   Now we allow correlations **across biomarkers** as well as **within biomarkers**.
-   Mathematically, we replace the block-diagonal assumption with a **Kronecker structure**:

$$
\mathrm{Cov}\!\big(\mathrm{vec}(\Theta_i)\big) 
   = \Sigma_P \otimes \Sigma_B
$$

-   Here:
    -   $\Sigma_P$ = covariance of the 5 parameters $(y_0, y_1, t_1, \alpha, \rho)$ within a biomarker.
    -   $\Sigma_B$ = covariance across biomarkers.
    -   The Kronecker product $\otimes$ builds a $5B \times 5B$ covariance.
-   Implementation plan:
    1.  Define priors for $\Sigma_P$ and $\Sigma_B$ separately (via Wishart distributions).
    2.  Build the Kronecker precision matrix $\text{T} = \text{T}_B \otimes \text{T}_P$ inside JAGS.
    3.  Draw each subject’s stacked parameter vector from this multivariate prior.
    4.  Likelihood for observed antibody data is unchanged — only the prior covariance differs.

------------------------------------------------------------------------

## E.1 Priors for the Correlated Model

The function `prep_priors_multi_b()` sets Wishart priors for both precision matrices:

**Within-biomarker precision** (5×5 for the 5 parameters per biomarker):
$$\text{T}_P \sim \text{Wishart}(\Omega_P, \nu_P)$$

**Across-biomarker precision** (B×B for B biomarkers):
$$\text{T}_B \sim \text{Wishart}(\Omega_B, \nu_B)$$

**Kronecker structure** combines them:
$$\text{T} = \text{T}_B \otimes \text{T}_P$$

This is a $(5B) \times (5B)$ precision matrix that captures both within and across-biomarker correlations.

### Default hyperparameters

```r
prep_priors_multi_b(
  n_blocks      = 2,           # Number of biomarkers
  omega_p_scale = rep(0.1, 5), # Diffuse for within-biomarker
  nu_p          = 6,           # Just above dimension (weakly informative)
  omega_b_scale = rep(1.0, 2), # Scale for across-biomarker  
  nu_b          = 3            # n_blocks + 1 (minimally informative)
)
```

These defaults are weakly informative, allowing the data to dominate. See `?prep_priors_multi_b` for details.


## E.2 The JAGS model with Kronecker precision

The function `write_model_ch2_kron()` creates a JAGS model file that differs from our baseline in one key way:

**Baseline model** (independence): Each biomarker gets its own precision matrix
$$\text{par}[\text{subj},b,] \sim \mathcal{N}( \mu_{\text{par}}[b,], \ \text{prec.par}[b,,] )$$
where biomarkers are independent.

**Kronecker model** (correlated): All biomarkers for a subject are drawn jointly
$$\mathrm{vec}(\text{par}_{\text{subj},\cdot,\cdot}) \sim \mathcal{N}\!\big( \mathrm{vec}(\mu_{\text{par}}), \ \text{T}_B \otimes \text{T}_P \big)$$
allowing correlation across biomarkers.

Everything else remains unchanged:
- Same transforms from parameters to natural scale
- Same likelihood for observed antibody data  
- Same hyperpriors on `mu.par` (parameter means)

The model file is written automatically when you call `run_mod(correlated = TRUE)`, or you can create it explicitly:

```r
# Optional: write model file to inspect
model_path <- write_model_ch2_kron("model_ch2_kron.jags")
```

## E.3: Using the unified `run_mod()` function

The correlated model functionality is integrated into `run_mod()`. Set `correlated = TRUE` to enable the Kronecker prior:

```r
# Independence model (default behavior)
fit_indep <- run_mod(data = sim_tbl, ...)

# Correlated model (Kronecker prior)
fit_kron <- run_mod(data = sim_tbl, correlated = TRUE, ...)
```

When `correlated = TRUE`, `run_mod()` internally:

1. Calls `build_kron_priors()` to combine base priors with Kronecker hyperparameters
2. Writes or uses `file_mod_kron` for the JAGS model with Kronecker structure
3. Uses `inits_kron()` for proper initialization
4. Monitors additional parameters: `TauB` and `TauP` (the precision matrices)


# Understanding the Wishart Hyperparameters

The Wishart distribution is the multivariate generalization of the gamma distribution, commonly used as a prior for precision matrices (inverse covariances).

## What are OmegaP, nuP, OmegaB, nuB?

For a Wishart distribution $\text{T} \sim \text{Wishart}(\Omega, \nu)$:

- **$\Omega$** (scale matrix): Determines the expected scale of the precision. Smaller diagonal entries → higher expected precision → tighter covariance
- **$\nu$** (degrees of freedom): Controls how informative the prior is. Larger $\nu$ → more concentrated around the expected value

In JAGS notation: $\mathop{\mathbb{E}}[\text{T}] \approx \nu \cdot \Omega^{-1}$ when $\nu$ exceeds the dimension of the matrix.

## Our Default Choices

**Within-biomarker precision** ($\text{T}_P$, 5×5):
```r
OmegaP = diag(rep(0.1, 5))  # Small scale = diffuse prior
nuP = 6                      # Just above dimension (5)
```

**Across-biomarker precision** ($\text{T}_B$, B×B):
```r
OmegaB = diag(rep(1.0, B))  # Moderate scale
nuB = B + 1                  # Minimally informative
```

These defaults are **weakly informative**: they allow the data to dominate while ensuring the prior is proper (integrable). 

## When to customize

Consider adjusting these if:
- You have strong prior information about parameter correlations
- Convergence is poor (try slightly more informative priors)
- You want to test sensitivity to prior choice

**Recommendation**: Start with defaults, then validate with prior predictive checks (simulate parameters → curves → sanity check ranges).

# Putting it all together

The complete workflow compares two models:

## Independence Model (Chapter 1 / Baseline)

```{r}
#| echo: true
#| eval: false

# Fit with default independence prior
fit_indep <- run_mod(
  data     = sim_tbl,
  nchain   = 4,
  nadapt   = 1000,
  nburn    = 500,
  nmc      = 500,
  niter    = 5000,
  strat    = NA
)
```

## Correlated Model (Chapter 2 / Kronecker)

```{r}
#| echo: true
#| eval: false

# Fit with Kronecker prior across biomarkers
fit_kron <- run_mod(
  data       = sim_tbl,
  correlated = TRUE,                    # <-- Enable Kronecker prior
  nchain     = 4,
  nadapt     = 1000,
  nburn      = 500,
  nmc        = 500,
  niter      = 5000,
  strat      = NA
)

# Optionally override default Kronecker hyperparameters
fit_kron_custom <- run_mod(
  data       = sim_tbl,
  correlated = TRUE,
  nchain     = 4,
  nadapt     = 1000,
  nburn      = 500,
  nmc        = 500,
  niter      = 5000,
  strat      = NA,
  # Pass through to prep_priors_multi_b():
  omega_p_scale = rep(0.2, 5),  # Custom within-biomarker scale
  nu_p          = 7,            # Custom degrees of freedom
  omega_b_scale = rep(1.5, 2),  # Custom across-biomarker scale
  nu_b          = 4             # Custom degrees of freedom
)
```

## Comparing Results

Both models return the same `sr_model` object structure, so downstream analysis is identical:

```{r}
#| echo: true
#| eval: false

# Inspect posterior summaries
fit_indep
fit_kron

# Plot predictions
plot_predicted_curve(fit_indep, sim_tbl)
plot_predicted_curve(fit_kron, sim_tbl)

# For the Kronecker model, you can also examine the precision matrices
library(ggmcmc)
fit_kron |>
  filter(Parameter %in% c("TauB[1,1]", "TauB[1,2]", "TauP[1,1]")) |>
  ggs_density()
```

