% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_residual_metrics.R
\name{compute_residual_metrics}
\alias{compute_residual_metrics}
\title{Compute Residual-Based Metrics for Posterior Predictions}
\usage{
compute_residual_metrics(
  model,
  dataset,
  ids,
  antigen_iso,
  scale = c("original", "log"),
  summary_level = c("id_antigen", "pointwise", "antigen", "overall")
)
}
\arguments{
\item{model}{An \code{sr_model} object (returned by \code{\link[=run_mod]{run_mod()}}) containing
samples from the posterior distribution of the model parameters.}

\item{dataset}{A \link[dplyr:tbl_df]{dplyr::tbl_df} with observed antibody response data.
Must contain:
\itemize{
\item \code{id}: participant ID
\item \code{timeindays} (or the time variable specified in the dataset attributes)
\item \code{value} (or the value variable specified in the dataset attributes)
\item \code{antigen_iso}: antigen-isotype combination
}}

\item{ids}{Character vector of participant IDs to compute residuals for.}

\item{antigen_iso}{The antigen isotype (e.g., "HlyE_IgA" or "HlyE_IgG").}

\item{scale}{Character string specifying the scale for residual computation.
Options:
\itemize{
\item \code{"original"}: Compute residuals on the original measurement scale
(default).
\item \code{"log"}: Compute residuals on the log scale, i.e.,
\code{log(obs) - log(pred_med)}. Non-positive values are removed with a
warning.
}}

\item{summary_level}{Character string specifying the aggregation level for
summary metrics. Options:
\itemize{
\item \code{"pointwise"}: Return one row per observation with individual residuals
(no summary).
\item \code{"id_antigen"}: Summary metrics per \verb{id × antigen_iso} combination
(default).
\item \code{"antigen"}: Summary metrics per \code{antigen_iso} (aggregated across IDs).
\item \code{"overall"}: Single overall summary across all IDs and antigens.
}}
}
\value{
A \link[dplyr:tbl_df]{dplyr::tbl_df} containing:

If \code{summary_level = "pointwise"}:
\itemize{
\item \code{id}: participant ID
\item \code{antigen_iso}: antigen-isotype combination
\item \code{t}: time in days
\item \code{obs}: observed value
\item \code{pred_med}: posterior median prediction
\item \code{pred_lower}: 2.5\% quantile of posterior predictions
\item \code{pred_upper}: 97.5\% quantile of posterior predictions
\item \code{residual}: raw residual (\code{obs - pred_med})
\item \code{abs_residual}: absolute residual (\code{abs(obs - pred_med)})
\item \code{sq_residual}: squared residual (\code{(obs - pred_med)^2})
}

If \code{summary_level} is \code{"id_antigen"}, \code{"antigen"}, or \code{"overall"}:
\itemize{
\item \code{id}: participant ID (if applicable to summary level)
\item \code{antigen_iso}: antigen-isotype combination (if applicable)
\item \code{MAE}: mean absolute error
\item \code{RMSE}: root mean squared error
\item \code{SSE}: sum of squared errors
\item \code{n_obs}: number of observations used in calculation
}
}
\description{
Computes residuals between observed antibody measurements and posterior
predicted values at observed timepoints. Returns pointwise residuals and/or
summary metrics (MAE, RMSE, SSE) at multiple aggregation levels.

This function provides quantitative posterior predictive diagnostics to
complement visual assessments from \code{\link[=plot_predicted_curve]{plot_predicted_curve()}}. It evaluates
how well the model predictions match observed data at the individual level.
}
\examples{
sees_model <- serodynamics::nepal_sees_jags_output
sees_data <- serodynamics::nepal_sees

# Example 1: Pointwise residuals for a single ID
pointwise_resid <- compute_residual_metrics(
  model = sees_model,
  dataset = sees_data,
  ids = "sees_npl_128",
  antigen_iso = "HlyE_IgA",
  scale = "original",
  summary_level = "pointwise"
)
print(pointwise_resid)

# Example 2: Summary metrics per ID × antigen_iso (default)
summary_per_id <- compute_residual_metrics(
  model = sees_model,
  dataset = sees_data,
  ids = "sees_npl_128",
  antigen_iso = "HlyE_IgA",
  scale = "original"
)
print(summary_per_id)

# Example 3: Multiple IDs with summary per ID
multi_id_summary <- compute_residual_metrics(
  model = sees_model,
  dataset = sees_data,
  ids = c("sees_npl_128", "sees_npl_131"),
  antigen_iso = "HlyE_IgA",
  scale = "original",
  summary_level = "id_antigen"
)
print(multi_id_summary)

# Example 4: Overall summary across multiple IDs
overall_summary <- compute_residual_metrics(
  model = sees_model,
  dataset = sees_data,
  ids = c("sees_npl_128", "sees_npl_131"),
  antigen_iso = "HlyE_IgA",
  scale = "original",
  summary_level = "overall"
)
print(overall_summary)

# Example 5: Log-scale residuals
log_resid <- compute_residual_metrics(
  model = sees_model,
  dataset = sees_data,
  ids = "sees_npl_128",
  antigen_iso = "HlyE_IgA",
  scale = "log",
  summary_level = "id_antigen"
)
print(log_resid)
}
